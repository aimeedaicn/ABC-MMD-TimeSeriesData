---
title: | 
  | Cosine model
author: 'Chennuo Dai'
subtitle: ""
output:
  bookdown::pdf_book:
    latex_engine: xelatex
    keep_tex: yes
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
bibliography: ["reference.bib"]
link-citations: true
editor_options: 
  markdown: 
    wrap: 72
---

<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
include_solutions <- TRUE
```

```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
```


# Cosine model with known parameters

# observed dataset y, true posterior
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)
library(scales)
library(coda)

source("src/Cosine.R")   

nobservation <- 100
cos_model    <- init_cosine_model(n = nobservation)
rprior       <- cos_model$rprior
dprior       <- cos_model$dprior
simulate     <- cos_model$simulate


method_names <- c("Summary statistics", "MMD", "Curve matching", "Delay reconstruction", "Curve matching and delay reconstruction", "True posterior") 

theta_star <- c(
  omega    = 1/80,
  phi      = pi/4,
  logsigma = 0,
  logA     = log(2)
)

seed_vec <- c(77)

traj_list <- lapply(seed_vec, function(s) {
  set.seed(s)
  y <- as.numeric(simulate(theta_star))   
  tibble(
    time  = seq_along(y),
    value = y,
    lab   = paste0("Seed ", s)
  )
})
df_all <- bind_rows(traj_list)

y_obs <- df_all$value

palette_fun <- scales::hue_pal()(length(seed_vec))
names(palette_fun) <- paste0("Seed ", seed_vec)

# observed dataset
plt <- ggplot(df_all, aes(x = time, y = value, colour = lab, group = lab)) +
  geom_line(size = 1.2) +
  scale_color_manual(values = palette_fun, guide = FALSE) +
  labs(x = "Time step", y = "Process value") +
  theme_classic(base_size = 14) +
  theme(
    panel.border   = element_rect(color = "black", fill = NA, size = 1),
    panel.grid     = element_blank(),
    axis.text      = element_text(size = 14),
    axis.title     = element_text(size = 14),
    legend.position = "none"
  )

palette_fun <- brewer.pal(n = length(unique(df_all$lab)), name = "Dark2")

plt <- ggplot(df_all, aes(x = time, y = value, colour = lab, group = lab)) +
  geom_line(size = 1.2) +
  scale_color_manual(values = palette_fun, guide = FALSE) +
  labs(x = expression(time~t), 
       y = expression(value~y[t]^{obs})) +
  theme_classic(base_size = 14) +
  theme(
    panel.border   = element_rect(color = "black", fill = NA, size = 1),
    panel.grid     = element_blank(),
    axis.text      = element_text(size = 20),
    axis.title     = element_text(size = 20),
    legend.position = "none"
  )

plot_dir   <- "plots/Cosine/"
result_dir <- "results/Cosine/"

ggsave(file.path(plot_dir, "observed_dataset.pdf"), plt, width = 14, height = 6)

# true posterior via Metropolisâ€“Hastings for the cosine model 

# log-likelihood
loglik_cosine <- function(par, y) {
  omg <- par[1]; ph <- par[2]; ls <- par[3]; lA <- par[4]
  if (omg < 0 || omg > 0.1 || ph < 0 || ph > 2*pi) return(-Inf)
  sigma <- exp(ls); A <- exp(lA)
  t <- seq_along(y)
  mu <- A * cos(2*pi*omg*t + ph)
  n <- length(y)
  -0.5*n*log(2*pi*sigma^2) - sum((y - mu)^2) / (2*sigma^2)
}

# log-prior
logprior_cosine <- function(par) {
  omg <- par[1]; ph <- par[2]; ls <- par[3]; lA <- par[4]
  if (omg < 0 || omg > 0.1 || ph < 0 || ph > 2*pi) return(-Inf)
  (-log(0.1)) + (-log(2*pi)) + dnorm(ls, 0, 1, log = TRUE) + dnorm(lA, 0, 1, log = TRUE)
}

logpost_cosine <- function(par, y) loglik_cosine(par, y) + logprior_cosine(par)

# simple random-walk MH
mh_cosine <- function(init, niter, prop_sd, y) {
  chain <- matrix(NA_real_, nrow = niter, ncol = 4)
  colnames(chain) <- c("omega","phi","logsigma","logA")
  lp <- rep(NA_real_, niter)
  cur <- init
  cur_lp <- logpost_cosine(cur, y)
  for (i in seq_len(niter)) {
    prop <- cur
    prop[1] <- rnorm(1, cur[1], prop_sd[1])
    prop[2] <- (cur[2] + rnorm(1, 0, prop_sd[2])) %% (2*pi)
    prop[3] <- rnorm(1, cur[3], prop_sd[3])
    prop[4] <- rnorm(1, cur[4], prop_sd[4])
    prop_lp <- logpost_cosine(prop, y)
    if (is.finite(prop_lp) && log(runif(1)) < (prop_lp - cur_lp)) {
      cur <- prop
      cur_lp <- prop_lp
    }
    chain[i, ] <- cur
    lp[i] <- cur_lp
  }
  list(chain = chain, logpost = lp)
}

set.seed(77)
niter <- 100000L
burn <- 50000L
prop_sd <- c(5e-4, 0.05, 0.05, 0.05)
init_par <- c(theta_star["omega"], theta_star["phi"], theta_star["logsigma"], theta_star["logA"])
mh_out <- mh_cosine(init_par, niter, prop_sd, y_obs)
post_draws <- as.data.frame(mh_out$chain[(burn+1L):niter, ])
colnames(post_draws) <- c("omega","phi","logsigma","logA")

dens_list <- list(
  omega = density(post_draws$omega),
  phi = density(post_draws$phi),
  logsigma = density(post_draws$logsigma),
  logA = density(post_draws$logA)
)

write.csv(data.frame(value = dens_list$omega$x, density = dens_list$omega$y, param = "omega", method = method_names[6]),
          file = file.path(result_dir, "posterior_marginal_omega.csv"), row.names = FALSE)
write.csv(data.frame(value = dens_list$phi$x, density = dens_list$phi$y, param = "phi", method = method_names[6]),
          file = file.path(result_dir, "posterior_marginal_phi.csv"), row.names = FALSE)
write.csv(data.frame(value = dens_list$logsigma$x, density = dens_list$logsigma$y, param = "logsigma", method = method_names[6]),
          file = file.path(result_dir, "posterior_marginal_logsigma.csv"), row.names = FALSE)
write.csv(data.frame(value = dens_list$logA$x, density = dens_list$logA$y, param = "logA", method = method_names[6]),
          file = file.path(result_dir, "posterior_marginal_logA.csv"), row.names = FALSE)

my_colours <- c(`True posterior` = brewer.pal(3, "Accent")[1])

plot_marginal <- function(df_x, true_val, xlab_expr) {
  ggplot(df_x, aes(x = value, y = density, colour = method, fill = method)) +
    geom_density(stat = "identity", alpha = 0.5) +
    scale_color_manual(name = "", values = my_colours) +
    scale_fill_manual(name = "", values = my_colours) +
    geom_vline(xintercept = true_val, linetype = 2) +
    labs(x = xlab_expr, y = "density") +
    theme_classic(base_size = 14) +
    theme(panel.border = element_rect(colour = "black", fill = NA),
          legend.position = "none")
}

df_post_omega <- read.csv(file.path(result_dir, "posterior_marginal_omega.csv"))
df_post_phi <- read.csv(file.path(result_dir, "posterior_marginal_phi.csv"))
df_post_lsg <- read.csv(file.path(result_dir, "posterior_marginal_logsigma.csv"))
df_post_lA <- read.csv(file.path(result_dir, "posterior_marginal_logA.csv"))

p_omega <- plot_marginal(df_post_omega, theta_star["omega"], expression(omega))
p_phi <- plot_marginal(df_post_phi, theta_star["phi"], expression(phi))
p_lsg <- plot_marginal(df_post_lsg, theta_star["logsigma"], expression(log(sigma)))
p_lA <- plot_marginal(df_post_lA, theta_star["logA"], expression(log(A)))

ggsave(file.path(plot_dir, "posterior_marginal_omega.pdf"), p_omega, width = 8, height = 6)
ggsave(file.path(plot_dir, "posterior_marginal_phi.pdf"), p_phi, width = 8, height = 6)
ggsave(file.path(plot_dir, "posterior_marginal_logsigma.pdf"), p_lsg, width = 8, height = 6)
ggsave(file.path(plot_dir, "posterior_marginal_logA.pdf"), p_lA, width = 8, height = 6)

# joint posterior of (omega, phi)
p_joint <- ggplot(post_draws, aes(x = omega, y = phi)) +
  stat_density_2d(aes(colour = after_stat(level)), bins = 10, size = 0.7) +
  scale_colour_distiller(palette = "Spectral", direction = -1, guide = "none") +
  labs(x = expression(omega), y = expression(phi)) +
  geom_vline(xintercept = theta_star["omega"], linetype = 2) +
  geom_hline(yintercept = theta_star["phi"], linetype = 2) +
  coord_cartesian(xlim = c(0, 0.1), ylim = c(0, 2*pi)) +
  theme_classic(base_size = 14) +
  theme(panel.border = element_rect(colour = "black", fill = NA))

ggsave(file.path(plot_dir, "posterior_contour.pdf"), p_joint, width = 8, height = 6)
```


# summary statistics
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(winference)
library(ggplot2)
library(dplyr)

source("src/sabc.R")
source("src/Cosine.R")


resultsprefix  <- "results/Cosine/"
plotprefix     <- "plots/Cosine/"

set.seed(77)

theta_star <- c(
  omega    = 1/80,
  phi      = pi/4,
  logsigma = 0,
  logA     = log(2)
)
theta_names    <- c("omega","phi","logsigma","logA") 
param_cols     <- paste0("samples.", theta_names)        
nobservation   <- length(y_obs) 
nthetas        <- 256
maxsimulation  <- 1*1e5

y <- y_obs

# Summary statistics 
sumstat <- function(z){
  z <- as.numeric(z)
  n <- length(z)
  m <- mean(z)
  se <- sd(z)/ sqrt(n)
  acf_vals <- acf(z, lag.max = 3, plot = FALSE)$acf[2:4]
  c(m, se, acf_vals)                
}

y_summary <- sumstat(y)

l2norm <- function(a, b) sqrt(sum((a - b)^2))      

eucdiscrep <- function(z){
  z_summary <- sumstat(z)
  l2norm(z_summary, y_summary)
}

# SMC
args_rej <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = eucdiscrep,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation           
)

rej_out <- sabc(args_rej, maxsimulation = maxsimulation)
save(rej_out, file = paste0(resultsprefix, "statistics.RData"))

rej_df <- as.data.frame(sabc_get_last_samples(rej_out)[, theta_names])
colnames(rej_df) <- param_cols
rej_df$methods   <- method_names[1]
rej_df <- rej_df[, c("methods", param_cols)]

write.csv(rej_df,
          file = paste0(resultsprefix, "statistics.csv"),
          row.names = FALSE)

```


# MMD
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(winference)
library(ggplot2)
library(dplyr)

source("src/sabc.R")
source("src/Cosine.R")
source("src/mmd/mmd_V.R")

resultsprefix  <- "results/Cosine/"
plotprefix     <- "plots/Cosine/"

set.seed(77)

theta_star <- c(
  omega    = 1/80,
  phi      = pi/4,
  logsigma = 0,
  logA     = log(2)
)
theta_names    <- c("omega","phi","logsigma","logA") 
param_cols     <- paste0("samples.", theta_names)        
nobservation   <- length(y_obs) 
nthetas        <- 256
maxsimulation  <- 1*1e5

y <- y_obs
bandwidth <- median(dist(y))

mmdsq <- function(z) mmd_V(matrix(y, ncol = 1), matrix(z, ncol = 1), bandwidth)

args_mmd <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = mmdsq,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation          
)

mmd_out <- sabc(args_mmd, maxsimulation = maxsimulation)
save(mmd_out, file = paste0(resultsprefix, "mmd.RData"))

mmd_df <- as.data.frame(sabc_get_last_samples(mmd_out)[, theta_names])
colnames(mmd_df) <- param_cols
mmd_df$methods   <- method_names[2]
mmd_df           <- mmd_df[, c("methods", param_cols)]

write.csv(mmd_df,
          file = paste0(resultsprefix, "mmd.csv"),
          row.names = FALSE)

```


# curve matching 
```{r echo=FALSE, message=FALSE, warning=FALSE}
set.seed(77)
source("src/mmd/mmdcurve_joint.R")
y <- y_obs
t_obs <- seq_along(y)                                

ell_x <- {
  d <- as.numeric(dist(matrix(y, ncol = 1)))
  med <- stats::median(d, na.rm = TRUE)
  max(med, 1e-8)
}
ell_t <- {
  d <- as.numeric(dist(t_obs))
  med <- stats::median(d, na.rm = TRUE)
  max(med, 1e-8)
}

ell_t <- 0.15


mmd_curve <- function(z){
  z   <- as.numeric(z)
  t_z <- seq_along(z) 
  mmdcurve_vstat_c(matrix(y, ncol = 1), matrix(z, ncol = 1),
                   t_obs, t_z,
                   ell_t, ell_x)
}

args_curve <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = mmd_curve,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation
)

curve_out <- sabc(args_curve, maxsimulation = maxsimulation)
save(curve_out, file = paste0(resultsprefix, "curve.RData"))

curve_df <- as.data.frame(sabc_get_last_samples(curve_out)[, theta_names])
colnames(curve_df) <- param_cols
curve_df$methods   <- method_names[3]
curve_df           <- curve_df[, c("methods", param_cols)]

write.csv(curve_df,
          file = paste0(resultsprefix, "curve.csv"),
          row.names = FALSE)  
```


# curve matching (optimal)
```{r echo=FALSE, message=FALSE, warning=FALSE}
# set.seed(77)
# source("src/mmd/mmdcurve_joint.R")
# 
# make_curve_disc_raw <- function(y_obs, lambda = 1) {
#   t_obs <- seq_along(y_obs)
#   ell_x0 <- {
#     d <- as.numeric(dist(matrix(y_obs, ncol = 1)))
#     med <- stats::median(d, na.rm = TRUE)
#     max(med, 1e-8)
#   }
#   ell_t0 <- {
#     d <- as.numeric(dist(t_obs))
#     med <- stats::median(d, na.rm = TRUE)
#     max(med, 1e-8)
#   }
#   ell_x <- ell_x0
#   ell_t <- max(lambda * ell_t0, 1e-8)
# 
#   function(z) {
#     z   <- as.numeric(z)
#     t_z <- seq_along(z)
#     mmdcurve_vstat_c(matrix(y_obs, ncol = 1), matrix(z, ncol = 1),
#                      t_obs, t_z,
#                      ell_t, ell_x)
#   }
# }
# 
# lambdas <- c(0.005, 0.01, 0.1, 1, 10)
# M       <- 10
# pilot_maxsim <- min(1e4, maxsimulation)
# 
# thetas_train <- rprior(M)
# ys_train <- lapply(seq_len(M), function(m) as.numeric(simulate(thetas_train[m, ])))
# 
# risk <- numeric(length(lambdas))
# for (k in seq_along(lambdas)) {
#   lambda_k <- lambdas[k]
#   losses_k <- numeric(M)
#   for (m in seq_len(M)) {
#     disc_m <- make_curve_disc_raw(ys_train[[m]], lambda = lambda_k)
# 
#     args_m <- list(
#       nthetas         = nthetas,
#       rprior          = rprior,
#       dprior          = dprior,
#       simulate        = simulate,
#       discrepancy     = disc_m,
#       parameter_names = theta_names,
#       thetadim        = length(theta_names),
#       ydim            = length(ys_train[[m]])
#     )
#     out_m <- sabc(args_m, maxsimulation = pilot_maxsim)
# 
#     sam_m <- as.data.frame(sabc_get_last_samples(out_m)[, theta_names])
#     theta_hat  <- colMeans(sam_m)
#     theta_true <- as.numeric(thetas_train[m, theta_names])
#     losses_k[m] <- sum( (theta_hat - theta_true)^2 )
#   }
#   risk[k] <- mean(losses_k)
#   message(sprintf("lambda = %.4f, avg MSE = %.6f", lambda_k, risk[k]))
# }
# lambda_star <- lambdas[ which.min(risk) ]
# message(sprintf("Chosen lambda* = %.4f", lambda_star))
# 
# 
# disc_star <- make_curve_disc_raw(y, lambda = lambda_star)
# 
# args_curve <- list(
#   nthetas         = nthetas,
#   rprior          = rprior,
#   dprior          = dprior,
#   simulate        = simulate,
#   discrepancy     = disc_star,
#   parameter_names = theta_names,
#   thetadim        = length(theta_names),
#   ydim            = nobservation
# )
# 
# curve_out <- sabc(args_curve, maxsimulation = maxsimulation)
# save(curve_out, file = file.path(resultsprefix, "curve.RData"))
# 
# curve_df <- as.data.frame(sabc_get_last_samples(curve_out)[, theta_names])
# colnames(curve_df) <- param_cols
# curve_df$methods   <- method_names[3]
# curve_df           <- curve_df[, c("methods", param_cols)]
# 
# write.csv(curve_df, file = file.path(resultsprefix, "curve.csv"), row.names = FALSE)
# 
# cat("\n===============================\n")
# cat(" Best lambda* selected =", lambda_star, "\n")
# cat("===============================\n\n")

```



# delay reconstruction
```{r echo=FALSE, message=FALSE, warning=FALSE}
set.seed(77)
source("src/mmd/reconstruction_V.R")            
source("src/sabc.R")   

y <- y_obs
delay_reconstruct <- function(series, tau = 1L, stride = 1L){
  series <- as.numeric(series)
  n  <- length(series)
  t0 <- max(tau) + 1L
  idx <- seq.int(t0, n, by = stride)
  m <- length(idx)
  d <- length(tau) + 1L
  M <- matrix(NA_real_, nrow = m, ncol = d)
  M[,1] <- series[idx]
  for (j in seq_along(tau)) {
    M[, j+1] <- series[idx - tau[j]]
  }
  colnames(M) <- c("y_t", paste0("y_t_minus_", tau))
  M
}

tau    <- c(2,7)
stride <- 2L    
Y_obs_delay <- delay_reconstruct(y, tau = tau, stride = stride)

bandwidth2 <- median(dist(Y_obs_delay))

mmddelay <- function(z_path){
  y_sim <- if (is.matrix(z_path)) as.numeric(z_path[,1]) else as.numeric(z_path)  
  Z_delay <- delay_reconstruct(y_sim, tau = tau, stride = stride)
  mmd_V_delay(Y_obs_delay, Z_delay, bandwidth2)  
}

args_delay <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,      
  discrepancy     = mmddelay,         
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation   
)

delay_out <- sabc(args_delay, maxsimulation = maxsimulation)
save(delay_out, file = paste0(resultsprefix, "mmddelay.RData"))

delay_df <- as.data.frame(sabc_get_last_samples(delay_out)[, theta_names])
colnames(delay_df) <- param_cols
delay_df$methods <- method_names[4]
delay_df           <- delay_df[, c("methods", param_cols)]

write.csv(delay_df,
          file = paste0(resultsprefix, "mmddelay.csv"),
          row.names = FALSE)

```


# combination
```{r echo=FALSE, message=FALSE, warning=FALSE}

set.seed(77)
source("src/mmd/mmdcurve_joint.R")   

y <- y_obs
delay_reconstruct_with_t <- function(series, tau = 1L, stride = 1L){
  series <- as.numeric(series)
  n  <- length(series)
  t0 <- max(tau) + 1L
  idx <- seq.int(t0, n, by = stride)       
  m <- length(idx)
  d <- length(tau) + 1L
  M <- matrix(NA_real_, nrow = m, ncol = d)
  M[,1] <- series[idx]
  for (j in seq_along(tau)) M[, j+1] <- series[idx - tau[j]]
  list(M = M, t = as.numeric(idx))         
}

tau    <- c(2, 7)
stride <- 2L

obs_delay <- delay_reconstruct_with_t(y, tau = tau, stride = stride)

ell_x_delay <- {
  d <- as.numeric(dist(obs_delay$M))
  med <- stats::median(d, na.rm = TRUE)
  max(med, 1e-8)
}

ell_t_delay <- {
  d <- as.numeric(dist(obs_delay$t))
  med <- stats::median(d, na.rm = TRUE)
  max(med, 1e-8)
}

ell_t_delay <- 0.15

mmd_delay_time <- function(z_path){
  y_sim <- if (is.matrix(z_path)) as.numeric(z_path[,1]) else as.numeric(z_path)
  sim_delay <- delay_reconstruct_with_t(y_sim, tau = tau, stride = stride)
  mmdcurve_vstat_c(
    obs_delay$M, sim_delay$M,   
    obs_delay$t, sim_delay$t,   
    ell_t_delay, ell_x_delay
  )
}

args_delay_time <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = mmd_delay_time,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = length(y)
)

combine_out <- sabc(args_delay_time, maxsimulation = maxsimulation)
save(combine_out, file = paste0(resultsprefix, "combine.RData"))

combine_df <- as.data.frame(sabc_get_last_samples(combine_out)[, theta_names])
colnames(combine_df) <- param_cols
combine_df$methods   <- method_names[5]  
combine_df           <- combine_df[, c("methods", param_cols)]

write.csv(combine_df,
          file = paste0(resultsprefix, "combine.csv"),
          row.names = FALSE)

```


# plot
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(winference)
library(ggplot2)
library(dplyr)
library(forcats)
library(RColorBrewer)
library(gridExtra)
library(microbenchmark)
library(readr)

resultsprefix <- "results/Cosine/"
plotprefix    <- "plots/Cosine/"
dir.create(plotprefix, recursive = TRUE, showWarnings = FALSE)

method_names <- c("Summary statistics", "MMD", "Curve matching",
                  "Delay reconstruction", "Curve matching and delay reconstruction",
                  "True posterior")

true_theta <- c(
  omega    = 1/80,
  phi      = pi/4,
  logsigma = 0,
  logA     = log(2)
)
true_vals <- true_theta 

mk_palette <- function(names, palette = "Set2") {
  maxc <- RColorBrewer::brewer.pal.info[palette, "maxcolors"]
  base <- RColorBrewer::brewer.pal(maxc, palette)
  cols <- if (length(names) <= maxc) base[seq_along(names)] else
    grDevices::colorRampPalette(base)(length(names))
  stats::setNames(cols, names)
}

my_colours <- c(
  "Summary statistics" = "#1f77b4",
  "MMD"                = "#ff7f0e",
  "Curve matching"     = "#FFD700",
  "Delay reconstruction" = "#228B22",
  "Curve matching and delay reconstruction" = "#9467bd",
  "True posterior"     = "#E41A1C"
)

statistics_df <- read_csv(file.path(resultsprefix, "statistics.csv"), show_col_types = FALSE) |>
  mutate(methods = method_names[1])
mmd_df        <- read_csv(file.path(resultsprefix, "mmd.csv"), show_col_types = FALSE) |>
  mutate(methods = method_names[2])
curve_df      <- read_csv(file.path(resultsprefix, "curve.csv"), show_col_types = FALSE) |>
  mutate(methods = method_names[3])
delay_df      <- read_csv(file.path(resultsprefix, "mmddelay.csv"), show_col_types = FALSE) |>
  mutate(methods = method_names[4])
combine_df    <- read_csv(file.path(resultsprefix, "combine.csv"), show_col_types = FALSE) |>
  mutate(methods = method_names[5])

fix_names <- function(df){
  nms <- names(df)
  map <- c("samples.theta1"="samples.omega",
           "samples.theta2"="samples.phi",
           "samples.theta3"="samples.logsigma",
           "samples.theta4"="samples.logA")
  for (k in names(map)) if (k %in% nms) names(df)[names(df)==k] <- map[[k]]
  df
}
statistics_df <- fix_names(statistics_df)
mmd_df        <- fix_names(mmd_df)
curve_df      <- fix_names(curve_df)
delay_df      <- fix_names(delay_df)
combine_df    <- fix_names(combine_df)

make_df_all <- function(sample_col, post_csv) {
  densities <- list(
    density(statistics_df[[sample_col]]),
    density(mmd_df       [[sample_col]]),
    density(curve_df     [[sample_col]]),
    density(delay_df     [[sample_col]]),
    density(combine_df   [[sample_col]])
  )
  df_abc <- lapply(seq_along(densities), function(i) {
    d <- densities[[i]]
    tibble(
      value   = d$x,
      density = d$y,
      methods = method_names[i]
    )
  }) |> bind_rows()
  df_post <- read_csv(file.path(resultsprefix, post_csv), show_col_types = FALSE) |>
    mutate(methods = method_names[6]) |>
    select(value, density, methods)
  bind_rows(df_abc, df_post)
}

df_omega_all <- make_df_all("samples.omega",    "posterior_marginal_omega.csv")
df_phi_all   <- make_df_all("samples.phi",      "posterior_marginal_phi.csv")
df_lsg_all   <- make_df_all("samples.logsigma", "posterior_marginal_logsigma.csv")
df_lA_all    <- make_df_all("samples.logA",     "posterior_marginal_logA.csv")

plot_marginal2 <- function(df_sub, true_val, xlab_expr,
                           legend_pos = c(0.95, 0.95), legend_just = c("right","top")) {
  df_draw <- df_sub |>
    dplyr::mutate(
      methods      = forcats::fct_relevel(methods, !!!method_names),   
      methods_draw = forcats::fct_relevel(methods, !!!rev(method_names)) 
    )

  ggplot(
    df_draw,
    aes(x = value, y = density,
        colour = methods, fill = methods,
        group  = methods_draw)   
  ) +
    geom_density(stat = "identity", alpha = 0.5) +
    geom_vline(xintercept = true_val, linetype = 2) +
    scale_color_manual(values = my_colours,
                       breaks = method_names, limits = method_names, name = "") +
    scale_fill_manual(values  = my_colours,
                      breaks = method_names, limits = method_names, name = "") +
    labs(x = xlab_expr, y = "density") +
    theme_classic(base_size = 14) +
    theme(panel.border       = element_rect(colour = "black", fill = NA),
            axis.text          = element_text(size = 14), 
  axis.title         = element_text(size = 20),  
          legend.position    = legend_pos,
          legend.justification = legend_just)
}


p_omega <- plot_marginal2(df_omega_all, true_vals["omega"],    expression(omega)) + xlim(0, 0.05)
p_phi   <- plot_marginal2(df_phi_all,   true_vals["phi"],      expression(phi))
p_lsg   <- plot_marginal2(df_lsg_all,   true_vals["logsigma"], expression(log(sigma)),
                          legend_pos = c(0.05, 0.95), legend_just = c("left","top"))
p_lA    <- plot_marginal2(df_lA_all,    true_vals["logA"],     expression(log(A)),
                          legend_pos = c(0.05, 0.95), legend_just = c("left","top"))

ggsave(file.path(plotprefix, "compare_omega.pdf"),    p_omega, width = 8, height = 6)
ggsave(file.path(plotprefix, "compare_phi.pdf"),      p_phi,   width = 8, height = 6)
ggsave(file.path(plotprefix, "compare_logsigma.pdf"), p_lsg,   width = 8, height = 6)
ggsave(file.path(plotprefix, "compare_logA.pdf"),     p_lA,    width = 8, height = 6)

# threshold
load(paste0(resultsprefix, "statistics.RData"))
load(paste0(resultsprefix, "mmd.RData"))
load(paste0(resultsprefix, "curve.RData"))
load(paste0(resultsprefix, "mmddelay.RData"))
load(paste0(resultsprefix, "combine.RData"))

threshold_history <- rbind(
  cbind(method_names[1], cumsum(rej_out$ncomputed),   rej_out$threshold_history),
  cbind(method_names[2], cumsum(mmd_out$ncomputed),   mmd_out$threshold_history),
  cbind(method_names[3], cumsum(curve_out$ncomputed), curve_out$threshold_history),
  cbind(method_names[4], cumsum(delay_out$ncomputed), delay_out$threshold_history),
  cbind(method_names[5], cumsum(combine_out$ncomputed), combine_out$threshold_history)
) |>
  as.data.frame() |>
  setNames(c("methods", "nsimulations", "thresholds")) |>
  mutate(
    nsimulations = as.numeric(as.character(nsimulations)),
    thresholds   = as.numeric(as.character(thresholds))
  )

draw_thresholds <- function(method_name) {
  dat <- threshold_history |> filter(methods == method_name)
  ggplot(dat, aes(x = nsimulations, y = thresholds, colour = methods)) +
    geom_line() +
    geom_point() +
    scale_color_manual(values = my_colours, name = "", breaks = method_names, limits = method_names,
                       guide = "none") +
    labs(x = "number of model simulations", y = "threshold") +
    xlim(0, max(threshold_history$nsimulations)) +
    theme_classic(base_size = 14) +
    theme(
      panel.border        = element_rect(colour = "black", fill = NA, size = 1)
    )
}

g1 <- draw_thresholds(method_names[1])
g2 <- draw_thresholds(method_names[2])
g3 <- draw_thresholds(method_names[3])
g4 <- draw_thresholds(method_names[4])
g5 <- draw_thresholds(method_names[5])

pdf(file.path(plotprefix, "thresholds.pdf"), width = 35, height = 6)
gridExtra::grid.arrange(g1, g2, g3, g4, g5, nrow = 1)
dev.off()

# computational times
ztemp <- simulate(true_theta)

timings <- microbenchmark(
  Euc     = eucdiscrep(ztemp),
  MMD     = mmdsq(ztemp),
  Curve   = mmd_curve(ztemp),
  Delay   = mmddelay(ztemp),
  Combine = mmd_delay_time(ztemp),
  times = 1000
)
print(timings)

```


# Code appendix

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```


