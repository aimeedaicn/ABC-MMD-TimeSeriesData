---
title: | 
  | OU process
author: 'Chennuo Dai'
subtitle: ""
output:
  bookdown::pdf_book:
    latex_engine: xelatex
    keep_tex: yes
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
bibliography: ["reference.bib"]
link-citations: true
editor_options: 
  markdown: 
    wrap: 72
---

<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
include_solutions <- TRUE
```

```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
```


# OU process with known parameters

# observed dataset y, true posterior
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)

source("src/OUprocess.R")  

nobservation <- 50                              
ou_model     <- init_ou_model(D = nobservation)  
rprior       <- ou_model$rprior
dprior       <- ou_model$dprior
simulate     <- ou_model$simulate

method_names <- c("Summary statistics", "MMD", "Curve matching", "Delay reconstruction", "True posterior") 

theta_star <- c(0.5, 1)   
seed_vec   <- c(57)

traj_list <- lapply(seed_vec, function(s) {
  set.seed(s)
  y <- as.numeric(simulate(theta_star))
  tibble(
    time  = seq_along(y),
    value = y,
    lab   = paste0("Seed ", s)
  )
})
df_all <- bind_rows(traj_list)

y_obs <- df_all$value               
D     <- length(y_obs)

palette_fun <- scales::hue_pal()(length(seed_vec))
names(palette_fun) <- paste0("Seed ", seed_vec)

# plot observed y trajectory
plt <- ggplot(df_all, aes(x = time, y = value, colour = lab, group = lab)) +
  geom_line(size = 1.2) +
  scale_color_manual(values = palette_fun, guide = FALSE) +
  labs(x = "Time step", y = "Process value") +
  theme_classic(base_size = 14) +
  theme(
    panel.border   = element_rect(color = "black", fill = NA, size = 1),
    panel.grid     = element_blank(),
    axis.text      = element_text(size = 14),  
    axis.title     = element_text(size = 14),
    legend.position = "none"
  )

plot_dir <- "plots/OUprocess/"
result_dir <- "results/OUprocess/"

ggsave(file.path(plot_dir, "observed_dataset.pdf"), plt, width = 14, height = 8)


# plot true posterior (marginal and contour)
delta_t <- ou_model$info$delta_t
sigma_w <- ou_model$info$sigma_w
sigma2  <- sigma_w^2 * delta_t

n_grid   <- 500
theta1_g <- seq(0, 1, length.out = n_grid)
theta2_g <- seq(-2, 2, length.out = n_grid)
dtheta1  <- theta1_g[2] - theta1_g[1]
dtheta2  <- theta2_g[2] - theta2_g[1]

# Eular approximate
loglik_fun <- function(th1, th2, x) {
  n <- length(x)
  mu <- x[-n] + th1 * (exp(th2) - x[-n]) * delta_t
  sum(dnorm(x[-1], mean = mu, sd = sqrt(sigma2), log = TRUE))
}


loglik_mat <- outer(theta1_g, theta2_g,
                    Vectorize(function(a, b) loglik_fun(a, b, y_obs)))

# normalization
post_mat <- exp(loglik_mat - max(loglik_mat))
post_mat <- post_mat / (sum(post_mat) * dtheta1 * dtheta2)

density_theta1 <- rowSums(post_mat) * dtheta2
density_theta2 <- colSums(post_mat) * dtheta1

df_theta1 <- tibble(value   = theta1_g,
                    density = density_theta1,
                    param   = "theta1",
                    method  = method_names[5])

df_theta2 <- tibble(value   = theta2_g,
                    density = density_theta2,
                    param   = "theta2",
                    method  = method_names[5])

df_long <- bind_rows(df_theta1, df_theta2)

write.csv(df_theta1,
          file = file.path(result_dir, "posterior_marginal_theta1.csv"),
          row.names = FALSE)
write.csv(df_theta2,
          file = file.path(result_dir, "posterior_marginal_theta2.csv"),
          row.names = FALSE)

# marginal
my_colours <- c(`True posterior` = brewer.pal(3, "Accent")[1])

plot_marginal <- function(df_sub, true_val, xlab_expr) {
  ggplot(df_sub, aes(x = value, y = density,
                     colour = method, fill = method)) +
    geom_density(stat = "identity", alpha = 0.5) +
    scale_color_manual(name = "", values = my_colours) +
    scale_fill_manual(name = "", values = my_colours) +
    geom_vline(xintercept = true_val, linetype = 2) +
    labs(x = xlab_expr, y = "density") +
    theme_classic(base_size = 14) +
    theme(panel.border = element_rect(colour = "black", fill = NA),
          legend.position = "none")
}

p_theta1 <- plot_marginal(df_long |> filter(param == "theta1"),
                          theta_star[1], expression(theta[1]))
p_theta2 <- plot_marginal(df_long |> filter(param == "theta2"),
                          theta_star[2], expression(theta[2]))

ggsave(file.path(plot_dir, "posterior_marginal_theta1.pdf"),
       p_theta1, width = 8, height = 6)
ggsave(file.path(plot_dir, "posterior_marginal_theta2.pdf"),
       p_theta2, width = 8, height = 6)

# contour
df_joint <- expand_grid(theta1 = theta1_g, theta2 = theta2_g) |>
  mutate(density = as.vector(t(post_mat)))

p_joint <- ggplot(df_joint, aes(theta1, theta2)) +
  geom_contour(aes(z = density, colour = after_stat(level)),  
               bins = 10, size = 0.7) +                        
  scale_colour_distiller(palette = "Spectral", direction = -1, 
                         guide = "none") +
  labs(x = expression(theta[1]), y = expression(theta[2])) +
  coord_cartesian(xlim = c(0.2, 0.8), ylim = c(0.3, 1.5)) +
  theme_classic(base_size = 14) +
  theme(panel.border = element_rect(colour = "black", fill = NA))

ggsave(file.path(plot_dir, "posterior_contour.pdf"),
       p_joint, width = 8, height = 6)
```



# summary statistics
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(winference)
library(ggplot2)
library(dplyr)

source("src/sabc.R")
source("src/OUprocess.R")

resultsprefix  <- "results/OUprocess/"
plotprefix     <- "plots/OUprocess/"

set.seed(7)

theta_star     <- list(theta = c(0.5, 1))  
theta_names    <- c("theta1", "theta2")
param_cols     <- paste0("samples.", theta_names) 

nobservation   <- length(y_obs)  
nthetas        <- 2048
maxsimulation  <- 1*1e5 

y <- y_obs

# summary statistics 
sumstat <- function(z){
  z <- as.numeric(z)
  n <- length(z)
  m <- mean(z)
  se <- sd(z) / sqrt(n)
  acf_vals <- acf(z, lag.max = 3, plot = FALSE)$acf[2:4]
  c(m, se, acf_vals)                
}

y_summary <- sumstat(y)

l2norm <- function(a, b) sqrt(sum((a - b)^2))      

eucdiscrep <- function(z){
  z_summary <- sumstat(z)
  l2norm(z_summary, y_summary)
}

# SMC
args_rej <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = eucdiscrep,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation           
)

rej_out <- sabc(args_rej, maxsimulation = maxsimulation)
save(rej_out, file = paste0(resultsprefix, "statistics.RData"))

rej_df <- as.data.frame(sabc_get_last_samples(rej_out)[, theta_names])
colnames(rej_df) <- param_cols
rej_df$methods   <- method_names[1]
rej_df <- rej_df[, c("methods", param_cols)]

write.csv(rej_df,
          file = paste0(resultsprefix, "statistics.csv"),
          row.names = FALSE)

```

# MMD
```{r echo=FALSE, message=FALSE, warning=FALSE}
set.seed(7)

source("src/mmd/mmd_V.R")
source("src/sabc.R")

bandwidth <- median(dist(y))

mmdsq <- function(z) mmd_V(matrix(y, ncol = 1), matrix(z, ncol = 1), bandwidth)

args_mmd <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = mmdsq,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation          
)

mmd_out <- sabc(args_mmd, maxsimulation = maxsimulation)
save(mmd_out, file = paste0(resultsprefix, "mmd.RData"))

mmd_df <- as.data.frame(sabc_get_last_samples(mmd_out)[, theta_names])
colnames(mmd_df) <- param_cols
mmd_df$methods   <- method_names[2]
mmd_df           <- mmd_df[, c("methods", param_cols)]

write.csv(mmd_df,
          file = paste0(resultsprefix, "mmd.csv"),
          row.names = FALSE)
```

# curve matching
```{r echo=FALSE, message=FALSE, warning=FALSE}
set.seed(7)

source("src/mmd/mmdcurve_joint.R")

t_obs <- seq_along(y)
d2_y_all <- as.vector((outer(y,      y,      "-"))^2)
d2_t_all <- as.vector((outer(t_obs,  t_obs,  "-"))^2)

ell_x <- {
  med <- median(sqrt(d2_y_all), na.rm = TRUE)
  if (is.finite(med) && med > 0) med else max(sd(y), 1e-6)
}
ell_t <- {
  med <- median(sqrt(d2_t_all), na.rm = TRUE)
  if (is.finite(med) && med > 0) med else max(sd(t_obs), 1e-6)
}

mmd_curve <- function(z){
  z    <- as.numeric(z)
  t_z  <- seq_along(z)
  mmdcurve_vstat_c(matrix(y, ncol = 1), matrix(z, ncol = 1),
                   t_obs, t_z,
                   ell_t, ell_x)
}

args_curve <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,
  discrepancy     = mmd_curve,
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation
)

curve_out <- sabc(args_curve, maxsimulation = maxsimulation)
save(curve_out, file = paste0(resultsprefix, "curve.RData"))

curve_df <- as.data.frame(sabc_get_last_samples(curve_out)[, theta_names])
colnames(curve_df) <- param_cols
curve_df$methods   <- method_names[3]
curve_df           <- curve_df[, c("methods", param_cols)]

write.csv(curve_df,
          file = paste0(resultsprefix, "curve.csv"),
          row.names = FALSE)  

```

# delay reconstruction
```{r echo=FALSE, message=FALSE, warning=FALSE}
set.seed(7)
source("src/mmd/reconstruction_V.R")            
source("src/sabc.R")   

delay_reconstruct <- function(series, tau = 1L, stride = 1L){
  series <- as.numeric(series)
  n  <- length(series)
  t0 <- max(tau) + 1L
  idx <- seq.int(t0, n, by = stride)
  m <- length(idx)
  d <- length(tau) + 1L
  M <- matrix(NA_real_, nrow = m, ncol = d)
  M[,1] <- series[idx]
  for (j in seq_along(tau)) {
    M[, j+1] <- series[idx - tau[j]]
  }
  colnames(M) <- c("y_t", paste0("y_t_minus_", tau))
  M
}

tau    <- c(1)
stride <- 1L     
Y_obs_delay <- delay_reconstruct(y, tau = tau, stride = stride)

bandwidth2 <- median(dist(Y_obs_delay))

mmddelay <- function(z_path){
  y_sim <- if (is.matrix(z_path)) as.numeric(z_path[,1]) else as.numeric(z_path)  
  Z_delay <- delay_reconstruct(y_sim, tau = tau, stride = stride)
  mmd_V_delay(Y_obs_delay, Z_delay, bandwidth2)  
}

args_delay <- list(
  nthetas         = nthetas,
  rprior          = rprior,
  dprior          = dprior,
  simulate        = simulate,      
  discrepancy     = mmddelay,         
  parameter_names = theta_names,
  thetadim        = length(theta_names),
  ydim            = nobservation   
)

delay_out <- sabc(args_delay, maxsimulation = maxsimulation)
save(delay_out, file = paste0(resultsprefix, "mmddelay.RData"))

delay_df <- as.data.frame(sabc_get_last_samples(delay_out)[, theta_names])
colnames(delay_df) <- param_cols
delay_df$methods   <- paste0(method_names[4], "delay")
delay_df           <- delay_df[, c("methods", param_cols)]

write.csv(delay_df,
          file = paste0(resultsprefix, "mmddelay.csv"),
          row.names = FALSE)

```

# plot
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(winference)
library(ggplot2)
library(dplyr)
library(forcats)          
library(RColorBrewer)     
library(gridExtra)        
library(microbenchmark) 

resultsprefix <- "results/OUprocess/"
plotprefix    <- "plots/OUprocess/"

method_names <- c("Summary statistics", "MMD", "Curve matching", "Delay reconstruction", "True posterior") 

true_theta   <- c(theta1 = 0.5, theta2 = 1)
my_colours   <- setNames(brewer.pal(length(method_names), "Set2"), method_names)

statistics_df <- read.csv(file.path(resultsprefix, "statistics.csv")) |>
  mutate(methods = method_names[1])
mmd_df        <- read.csv(file.path(resultsprefix, "mmd.csv")) |>
  mutate(methods = method_names[2])
curve_df      <- read.csv(file.path(resultsprefix, "curve.csv")) |>
  mutate(methods = method_names[3])
delay_df <- read.csv(paste0(resultsprefix, "mmddelay.csv"))      |> 
  mutate(methods = method_names[4])

make_df_all <- function(sample_col, post_csv) {
  densities <- list(
    density(statistics_df[[sample_col]]),
    density(mmd_df       [[sample_col]]),
    density(curve_df     [[sample_col]]),
    density(delay_df      [[sample_col]])
  )
  df_abc <- lapply(seq_along(densities), function(i) {
    d <- densities[[i]]
    tibble(
      value   = d$x,
      density = d$y,
      methods = method_names[i]
    )
  }) %>% bind_rows()
  
  df_post <- read.csv(file.path(resultsprefix, post_csv)) %>%
    mutate(methods = method_names[5])
  
  bind_rows(df_abc, df_post)
}

df1_all <- make_df_all("samples.theta1", "posterior_marginal_theta1.csv")
df2_all <- make_df_all("samples.theta2", "posterior_marginal_theta2.csv")

plot_marginal2 <- function(df_sub, true_val, xlab_expr) {
  df <- df_sub %>%
    mutate(
      methods = factor(methods, levels = method_names),
      methods_draw = factor(methods, levels = rev(method_names))
    )

  ggplot(
    df,
    aes(x = value, y = density,
        colour = methods, fill = methods,         
        group = methods_draw, order = methods_draw 
    )) +
    geom_density(stat = "identity", alpha = 0.5, position = "identity") +
    geom_vline(xintercept = true_val, linetype = 2) +
    scale_color_manual(values = my_colours, name = "", limits = method_names) +
    scale_fill_manual(values = my_colours,  name = "", limits = method_names) +
    labs(x = xlab_expr, y = "density") +
    theme_classic(base_size = 14) +
    theme(
      panel.border = element_rect(colour = "black", fill = NA),
      legend.position = c(0.95, 0.95),
      legend.justification = c("right", "top")
    )
}

p1 <- plot_marginal2(df1_all, true_theta["theta1"], expression(theta[1])) +
  theme(legend.position = c(0.95, 0.95),
        legend.justification = c("right", "top"))
p2 <- plot_marginal2(df2_all, true_theta["theta2"], expression(theta[2])) +
  theme(legend.position = c(0.05, 0.95),
        legend.justification = c("left", "top"))

ggsave(file.path(plotprefix, "compare_theta1.pdf"), p1, width = 8, height = 6)
ggsave(file.path(plotprefix, "compare_theta2.pdf"), p2, width = 8, height = 6)


# threshold
load(paste0(resultsprefix, "statistics.RData"))
load(paste0(resultsprefix, "mmd.RData"))
load(paste0(resultsprefix, "curve.RData"))   

threshold_history <- rbind(
  cbind(method_names[1], cumsum(rej_out$ncomputed),   rej_out$threshold_history),
  cbind(method_names[2], cumsum(mmd_out$ncomputed),   mmd_out$threshold_history),
  cbind(method_names[3], cumsum(curve_out$ncomputed), curve_out$threshold_history),
  cbind(method_names[4], cumsum(delay_out$ncomputed), delay_out$threshold_history)
) |>
  as.data.frame() |>
  setNames(c("methods", "nsimulations", "thresholds")) |>
  mutate(
    nsimulations = as.numeric(as.character(nsimulations)),
    thresholds   = as.numeric(as.character(thresholds))
  )

draw_thresholds <- function(method_name) {
  dat <- threshold_history |> filter(methods == method_name)

  ggplot(dat, aes(x = nsimulations, y = thresholds, colour = methods)) +
    geom_line() +
    geom_point() +
    scale_color_manual(values = my_colours, name = "") +
    labs(x = "number of model simulations", y = "threshold") +
    xlim(0, max(threshold_history$nsimulations)) +
    theme_classic(base_size = 14) +
    theme(
      panel.border        = element_rect(colour = "black", fill = NA, size = 1),
      legend.position     = c(0.95, 0.95),
      legend.justification= c("right", "top"),
      legend.key          = element_blank(),
      legend.background   = element_blank(),
      legend.text         = element_text(size = 12),
      axis.title          = element_text(size = 14),
      axis.text           = element_text(size = 12)
    )
}

g1 <- draw_thresholds(method_names[1])
g2 <- draw_thresholds(method_names[2])
g3 <- draw_thresholds(method_names[3])
g4 <- draw_thresholds(method_names[4])

pdf(file.path(plotprefix, "thresholds.pdf"), width = 24, height = 6)
gridExtra::grid.arrange(g1, g2, g3, g4, nrow = 1)
dev.off()


# time
ztemp <- simulate(true_theta)

timings <- microbenchmark(
  Euc   = eucdiscrep(ztemp),
  MMD   = mmdsq(ztemp),
  Curve = mmd_curve(ztemp),
  Delay = mmddelay(ztemp),
  times = 1000
)

print(timings)


```

# assessment
```{r echo=FALSE, message=FALSE, warning=FALSE}
source("src/assessment.R")   

true_samples <- sample_from_grid_posterior(
  theta1_g = theta1_g, theta2_g = theta2_g, post_mat = post_mat, n = 5000
)

seeds_eval <- seq(from = 227, by = 100, length.out = 20)
samples_by_method <- list(
  "Summary statistics"   = vector("list", length(seeds_eval)),
  "MMD"                  = vector("list", length(seeds_eval)),
  "Curve matching"       = vector("list", length(seeds_eval)),
  "Delay reconstruction" = vector("list", length(seeds_eval))
)

run_once <- function(seed, args_list) {
  set.seed(seed)
  out <- sabc(args_list, maxsimulation = maxsimulation)
  as.matrix(sabc_get_last_samples(out)[, theta_names])
}

args_sumstat <- list(
  nthetas = nthetas, rprior = rprior, dprior = dprior, simulate = simulate,
  discrepancy = eucdiscrep, parameter_names = theta_names,
  thetadim = length(theta_names), ydim = nobservation
)
args_mmd <- list(
  nthetas = nthetas, rprior = rprior, dprior = dprior, simulate = simulate,
  discrepancy = mmdsq, parameter_names = theta_names,
  thetadim = length(theta_names), ydim = nobservation
)
args_curve <- list(
  nthetas = nthetas, rprior = rprior, dprior = dprior, simulate = simulate,
  discrepancy = mmd_curve, parameter_names = theta_names,
  thetadim = length(theta_names), ydim = nobservation
)
args_delay <- list(
  nthetas = nthetas, rprior = rprior, dprior = dprior, simulate = simulate,
  discrepancy = mmddelay, parameter_names = theta_names,
  thetadim = length(theta_names), ydim = nobservation
)

for (j in seq_along(seeds_eval)) {
  sd <- seeds_eval[j]
  message(sprintf("== Running seed %d ==", sd))

  samples_by_method[["Summary statistics"]][[j]]   <- run_once(sd, args_sumstat)
  samples_by_method[["MMD"]][[j]]                  <- run_once(sd, args_mmd)
  samples_by_method[["Curve matching"]][[j]]       <- run_once(sd, args_curve)
  samples_by_method[["Delay reconstruction"]][[j]] <- run_once(sd, args_delay)
}

metrics_df <- assess_posteriors(
  true_samples      = true_samples,
  samples_by_method = samples_by_method,
  n_projections     = 300L,     
  sigma             = "median"  
)

write.csv(metrics_df, file.path(resultsprefix, "assessment.csv"),
          row.names = FALSE)

if (!dir.exists(plotprefix)) dir.create(plotprefix, recursive = TRUE)
plot_assessment_boxplots(metrics_df,
  out_file = file.path(plotprefix, "assessment.pdf")
)
```



# Code appendix

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```



